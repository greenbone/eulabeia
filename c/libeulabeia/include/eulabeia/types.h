/* Copyright (C) 2021 Greenbone Networks GmbH
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef __EULABEIA_DATA_H
#define __EULABEIA_DATA_H
/**
 * @brief defines the scan result states.
 *
 * The first parameter is used to generate enum eulabeia_scan_state and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum
 * eulabeia_scan_state.
 *
 */
#define EULABEIA_SCAN_STATES                                                   \
	X(EULABEIA_SCAN_REQUESTED, requested)                                  \
	X(EULABEIA_SCAN_QUEUED, queued)                                        \
	X(EULABEIA_SCAN_INIT, init)                                            \
	X(EULABEIA_SCAN_RUNNING, running)                                      \
	X(EULABEIA_SCAN_STOPPING, stopping)                                    \
	X(EULABEIA_SCAN_STOPPED, stopped)                                      \
	X(EULABEIA_SCAN_INTERRUPTED, interrupted)                              \
	X(EULABEIA_SCAN_FAILED, failed)                                        \
	X(EULABEIA_SCAN_FINISHED, finished)

//@brief enum generated of first parameter of EULABEIA_SCAN_STATES
enum eulabeia_scan_state {
#define X(a, b) a,
	EULABEIA_SCAN_STATES
#undef X
};

/**
 * @brief defines the CRUD states.
 *
 * The first parameter is used to generate enum eulabeia_crud_state and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum
 * eulabeia_crud_state.
 *
 */
#define EULABEIA_CRUD_STATES                                                   \
	X(EULABEIA_CRUD_REQUESTED, requested)                                  \
	X(EULABEIA_CRUD_FAILED, failed)                                        \
	X(EULABEIA_CRUD_SUCCESS, success)

/*
 * @brief represent the status when a CRUD cmd was send.
 *
 * It is generated by EULABEIA_CRUD_STATES.
 */
enum eulabeia_crud_state {
#define X(a, b) a,
	EULABEIA_CRUD_STATES
#undef X
};

/**
 * @brief defines the message types within eulabeia.
 *
 * The first parameter is used to generate enum eulabeia_message_type,
 * the second parameter is used to translate from and to the json
 * representation, the third parameter is used to generate the topic (can be
 * either info or cmd).
 *
 * To add a new type add it here and NOT within enum eulabeia_message_type.
 *
 */
#define EULABEIA_MESSAGE_TYPES                                                 \
	X(EULABEIA_UNKNOWN, NA, NA)                                            \
	X(EULABEIA_CMD_START, start, cmd)                                      \
	X(EULABEIA_CMD_STOP, stop, cmd)                                        \
	X(EULABEIA_CMD_MODIFY, modify, cmd)                                    \
	X(EULABEIA_INFO_MODIFIED, modified, info)                              \
	X(EULABEIA_INFO_STATUS, status, info)                                  \
	X(EULABEIA_INFO_FAILURE, failure, info)

//@brief enum generated of first parameter of EULABEIA_MESSAGE_TYPES
enum eulabeia_message_type {
#define X(a, b, c) a,
	EULABEIA_MESSAGE_TYPES
#undef X
};

/**
 * @brief defines the aggregates.
 *
 * The first parameter is used to generate enum eulabeia_aggregate and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum eulabeia_aggregate.
 *
 */
#define EULABEIA_AGGREGATES                                                    \
	X(EULABEIA_SCAN, scan)                                                 \
	X(EULABEIA_TARGET, target)

//@brief enum generated of first parameter of EULABEIA_AGGREGATES
enum eulabeia_aggregate {
#define X(a, b) a,
	EULABEIA_AGGREGATES
#undef X
};
/*
 * @brief contains all data every message within scanner context must have.
 *
 * Every json message within the scanner context must have the fields:
 * - type; will be used to identify the message type e.g. start.scan
 * - id; a unique message id to search for a message
 * - group_id; an id for a series of message belong in the same context
 * - created; a epoch in nanoseconds when the message got created
 */
struct EulabeiaMessage {
	char *type;
	char *id;
	char *group_id;
	unsigned long created;
};

struct EulabeiaStatus {
	struct EulabeiaMessage *message;
	char *id;
	char *status;
};

struct EulabeiaFailure {
	struct EulabeiaMessage *message;
	char *id;
	char *error;
};

struct EulabeiaIDMessage {
	struct EulabeiaMessage *message;
	char *id;
};

struct EulabeiaScanResult {
	char *oid;
	char *port;
	char *ip;
};

struct EulabeiaScanResults {
	struct EulabeiaScanResult *results;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaScanProgress {
	enum eulabeia_scan_state status;
	struct EulabeiaScanResults *results;
};

struct EulabeiaCRUDProgress {
	enum eulabeia_crud_state status;
};

struct EulabeiaHost {
	char *address;
};

struct EulabeiaHosts {
	struct EulabeiaHost *hosts;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaCredential {
	char *category;
	char *key;
	char *value;
};

struct EulabeiaCredentials {
	struct EulabeiaCredential *credentials;
	unsigned int len;
	unsigned int cap;
};
struct EulabeiaPort {
	char *port;
};

struct EulabeiaPorts {
	struct EulabeiaPort *ports;
	unsigned int len;
	unsigned int cap;
};
struct EulabeiaPlugin {
	char *oid;
};

struct EulabeiaPlugins {
	struct EulabeiaPlugin *plugins;
	unsigned int len;
	unsigned int cap;
};
struct EulabeiaTarget {
	char *id;
	struct EulabeiaHosts *hosts;
	struct EulabeiaPlugins *plugins;
	struct EulabeiaPorts *ports;
	char *sensor;
	int alive;
	int parallel;
	struct EulabeiaHosts *exclude;
	struct EulabeiaCredentials *credentials;
};

struct EulabeiaScan {
	char *id;
	char *target_id; // set only target_id or target not both.
	struct EulabeiaHosts *finished;
	int temporary;
	struct EulabeiaTarget *target;
};
/*
 * @brief translates eulabeia_scan_state to an char array.
 *
 * The implementation of eulabeia_scan_state_to_str is generated via
 * the second parameter of EULABEIA_SCAN_STATES.
 *
 * @param[in] srs the eulabeia_scan_state to translate
 * @return a char array representation of eulabeia_scan_state or NULL
 * when undefined
 */
char *eulabeia_scan_state_to_str(enum eulabeia_scan_state srs);

/*
 * @brief translates eulabeia_message_type to an char array.
 *
 * The implementation of eulabeia_message_type_to_str is generated via
 * the second parameter of EULABEIA_MESSAGE_TYPES.
 *
 * @param[in] srs the eulabeia_message_type to translate
 * @return a char array representation of eulabeia_message_type or NULL when
 * undefined
 */
char *eulabeia_message_type_to_str(enum eulabeia_message_type mt);

/*
 * @brief translates eulabeia_aggregate to an char array.
 *
 * The implementation of eulabeia_aggregate_to_str is generated via
 * the second parameter of EULABEIA_AGGREGATES.
 *
 * @param[in] srs the eulabeia_aggregate to translate
 * @return a char array representation of eulabeia_aggregate or NULL when
 * undefined
 */
char *eulabeia_aggregate_to_str(enum eulabeia_aggregate mt);

/*
 * @brief returns the eulabeia_message_type of a message.
 *
 * @param[in] message; the message to get the message_type from
 * @return eulabeia_message_type
 */
enum eulabeia_message_type
eulabeia_message_to_message_type(const struct EulabeiaMessage *message);

/*
 * @brief destroyes an EulabeiaMessage
 *
 * @param[out] msg, the EulabeiaMessage to be freed. Sets *msg to NULL.
 */
void eulabeia_message_destroy(struct EulabeiaMessage **msg);
void eulabeia_failure_destroy(struct EulabeiaFailure **failure);
void eulabeia_status_destroy(struct EulabeiaStatus **status);
void eulabeia_hosts_destroy(struct EulabeiaHosts **hosts);
void eulabeia_plugins_destroy(struct EulabeiaPlugins **plugins);
void eulabeia_ports_destroy(struct EulabeiaPorts **ports);
char *eulabeia_message_type(enum eulabeia_message_type message_type,
			    enum eulabeia_aggregate aggregate);
struct EulabeiaMessage *
eulabeia_initialize_message(enum eulabeia_message_type message_type,
			    enum eulabeia_aggregate aggregate,
			    char *group_id);

char *eulabeia_scan_state_to_str(enum eulabeia_scan_state srs);

char *eulabeia_message_type_to_event_type(enum eulabeia_message_type mt);

char *eulabeia_message_type_to_str(enum eulabeia_message_type mt);

char *eulabeia_aggregate_to_str(enum eulabeia_aggregate a);

#endif
