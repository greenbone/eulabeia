/* Copyright (C) 2021 Greenbone Networks GmbH
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef __EULABEIA_DATA_H
#define __EULABEIA_DATA_H
/**
 * @brief defines the scan result states.
 *
 * The first parameter is used to generate enum eulabeia_scan_state and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum
 * eulabeia_scan_state.
 *
 */
#define EULABEIA_SCAN_STATES                                                   \
	X(EULABEIA_SCAN_REQUESTED, requested)                                  \
	X(EULABEIA_SCAN_QUEUED, queued)                                        \
	X(EULABEIA_SCAN_INIT, init)                                            \
	X(EULABEIA_SCAN_RUNNING, running)                                      \
	X(EULABEIA_SCAN_STOPPING, stopping)                                    \
	X(EULABEIA_SCAN_STOPPED, stopped)                                      \
	X(EULABEIA_SCAN_INTERRUPTED, interrupted)                              \
	X(EULABEIA_SCAN_FAILED, failed)                                        \
	X(EULABEIA_SCAN_FINISHED, finished)

//@brief enum generated of first parameter of EULABEIA_SCAN_STATES
enum eulabeia_scan_state {
#define X(a, b) a,
	EULABEIA_SCAN_STATES
#undef X
};

/**
 * @brief defines the CRUD states.
 *
 * The first parameter is used to generate enum eulabeia_crud_state and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum
 * eulabeia_crud_state.
 *
 */
#define EULABEIA_CRUD_STATES                                                   \
	X(EULABEIA_CRUD_REQUESTED, requested)                                  \
	X(EULABEIA_CRUD_FAILED, failed)                                        \
	X(EULABEIA_CRUD_SUCCESS, success)

/*
 * @brief represent the status when a CRUD cmd was send.
 *
 * It is generated by EULABEIA_CRUD_STATES.
 */
enum eulabeia_crud_state {
#define X(a, b) a,
	EULABEIA_CRUD_STATES
#undef X
};

/**
 * @brief defines the message types within eulabeia.
 *
 * The first parameter is used to generate enum eulabeia_message_type,
 * the second parameter is used to translate from and to the json
 * representation, the third parameter is used to generate the topic (can be
 * either info or cmd).
 *
 * To add a new type add it here and NOT within enum eulabeia_message_type.
 *
 */
#define EULABEIA_MESSAGE_TYPES                                                 \
	X(EULABEIA_UNKNOWN, NA, NA)                                            \
	X(EULABEIA_CMD_CREATE, create, cmd)                                    \
	X(EULABEIA_CMD_START, start, cmd)                                      \
	X(EULABEIA_CMD_STOP, stop, cmd)                                        \
	X(EULABEIA_CMD_GET, get, cmd)                                          \
	X(EULABEIA_CMD_MODIFY, modify, cmd)                                    \
	X(EULABEIA_INFO_CREATED, created, info)                                \
	X(EULABEIA_INFO_MODIFIED, modified, info)                              \
	X(EULABEIA_INFO_STOPPED, stopped, info)                                \
	X(EULABEIA_INFO_STATUS, status, info)                                  \
	X(EULABEIA_INFO_GOT, got, info)                                        \
	X(EULABEIA_INFO_SCAN_RESULT, result, info)                             \
	X(EULABEIA_INFO_START_FAILURE, failure.start, info)                    \
	X(EULABEIA_INFO_STOP_FAILURE, failure.stop, info)                      \
	X(EULABEIA_INFO_CREATE_FAILURE, failure.create, info)                  \
	X(EULABEIA_INFO_MODIFY_FAILURE, failure.modify, info)                  \
	X(EULABEIA_INFO_GET_FAILURE, failure.get, info)                        \
	X(EULABEIA_INFO_FAILURE, failure, info)

//@brief enum generated of first parameter of EULABEIA_MESSAGE_TYPES
enum eulabeia_message_type {
#define X(a, b, c) a,
	EULABEIA_MESSAGE_TYPES
#undef X
};

/**
 * @brief defines the aggregates.
 *
 * The first parameter is used to generate enum eulabeia_aggregate and
 * the second parameter is used to translate from and to the json
 * representation.
 *
 * To add a new state add it here and NOT within enum eulabeia_aggregate.
 *
 */
#define EULABEIA_AGGREGATES                                                    \
	X(EULABEIA_AGGREGATE_UNKNOWN, unknown)                                 \
	X(EULABEIA_PLUGIN, vt)                                                 \
	X(EULABEIA_SCAN, scan)                                                 \
	X(EULABEIA_TARGET, target)

//@brief enum generated of first parameter of EULABEIA_AGGREGATES
enum eulabeia_aggregate {
#define X(a, b) a,
	EULABEIA_AGGREGATES
#undef X
};

/**
 * @brief defines result types
 *
 * Result types are sent by the scanner. Most of them are from openvas and
 * don't follow the typical eulabeia format.
 *
 * The first value is used as a enum identifier and the second is used to parse
 * the enum from and to string. Currently openvas is sending it in uppercase.
 */
#define EULABEIA_RESULT_TYPES                                                  \
	X(EULABEIA_RESULT_TYPE_UNKNOWN, "UNKNOWN")                             \
	X(EULABEIA_RESULT_TYPE_HOST_START, "HOST_START")                       \
	X(EULABEIA_RESULT_TYPE_HOST_END, "HOST_END")                           \
	X(EULABEIA_RESULT_TYPE_ERRMSG, "ERRMSG")                               \
	X(EULABEIA_RESULT_TYPE_LOG, "LOG")                                     \
	X(EULABEIA_RESULT_TYPE_HOST_DETAIL, "HOST_DETAIL")                     \
	X(EULABEIA_RESULT_TYPE_ALARM, "ALARM")

enum eulabeia_result_type {
#define X(a, b) a,
	EULABEIA_RESULT_TYPES
#undef X
};

/**
 * @brief Defines host status types
 *
 * Host status are sent by the scanner main process or the host process.
 * They don't follow the typical eulabeia format.
 * These messages are mainly for progress calculation and don't end in the
 * client.
 *
 * The first value is used as a enum identifier and the second is used to parse
 * the enum from and to string. Currently openvas is sending it in uppercase.
 */
#define EULABEIA_HOST_STATUS_TYPES                                             \
	X(EULABEIA_HOST_STATUS_TYPE_UNKNOWN, "HOST_STATUS_UNKNOWN")            \
	X(EULABEIA_HOST_STATUS_TYPE_HOST_COUNT, "HOST_COUNT")                  \
	X(EULABEIA_HOST_STATUS_TYPE_DEADHOST, "DEADHOST")                      \
	X(EULABEIA_HOST_STATUS_TYPE_HOST_STATUS, "HOST_PROGRESS")              \
	X(EULABEIA_HOST_STATUS_TYPE_ERRMSG, "HOST_ERRMSG")

enum eulabeia_host_status_type {
#define X(a, b) a,
	EULABEIA_HOST_STATUS_TYPES
#undef X
};

/*
 * @brief contains all data every message within scanner context must have.
 *
 * Every json message within the scanner context must have the fields:
 * - type; will be used to identify the message type e.g. start.scan
 * - id; a unique message id to search for a message
 * - group_id; an id for a series of message belong in the same context
 * - created; a epoch in nanoseconds when the message got created
 */
struct EulabeiaMessage {
	char *type;
	char *id;
	char *group_id;
	char *destination;
	unsigned long created;
};

struct EulabeiaStatus {
	struct EulabeiaMessage *message;
	char *id;
	char *status; // TODO enum
};

struct EulabeiaFailure {
	struct EulabeiaMessage *message;
	char *id;
	char *error;
};

struct EulabeiaIDMessage {
	struct EulabeiaMessage *message;
	char *id;
};

struct EulabeiaScanResult {
	struct EulabeiaMessage *message;
	char *result_type; // TODO enum
	char *host_ip;
	char *host_name;
	char *port;
	char *id;
	char *oid;
	char *value;
	char *uri;
};

struct EulabeiaHostStatus {
	struct EulabeiaMessage *message;
	enum eulabeia_host_status_type host_status_type;
	char *host_ip;
	char *id;
	char *value;
};

struct EulabeiaScanResults {
	struct EulabeiaScanResult *results;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaScanProgress {
	enum eulabeia_scan_state status;
	struct EulabeiaScanResults *results;
};

/*
 * @brief EulabeiaCRUDProgress contains progress data for create, read, update
 * or delete messages.
 *
 * Usually it is used in combination with eulabeia_crud_progress for the purpose
 * to verify the status of a previously send command. On get cmds it  will also
 * contain the aggregate information when it is a read operation depending on
 * the aggregate.
 *
 * @var status contains the statues of a cmd
 * @var target contains the target, it is only set on got.target
 * @var scan contains the scan, it is only set on got.scan
 * @var scan contains the plugin, it is only set on got.vt
 *
 */
struct EulabeiaCRUDProgress {
	enum eulabeia_crud_state status;
	struct EulabeiaTarget *target;
	struct EulabeiaScan *scan;
	struct EulabeiaPlugin *plugin;
};

struct EulabeiaHost {
	char *address;
};

struct EulabeiaHosts {
	struct EulabeiaHost *hosts;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaCredential {
	char *category;
	char *key;
	char *value;
};

struct EulabeiaCredentials {
	struct EulabeiaCredential *credentials;
	unsigned int len;
	unsigned int cap;
};
struct EulabeiaPort {
	char *port;
};

struct EulabeiaPorts {
	struct EulabeiaPort *ports;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaPluginReference {
	char *id;
	char *name;
	char *value;
	char *type;
	char *description;
	char *defaultvalue;
};

struct EulabeiaPluginReferences {
	struct EulabeiaPluginReference *reference;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaPluginParameter {
	char *type;
	char *id;
};

struct EulabeiaPluginParameters {
	struct EulabeiaPluginParameter *parameter;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaPluginDependency {
	char *oid;
};

struct EulabeiaPluginDependencies {
	struct EulabeiaPluginDependency *dependency;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaPluginSeverity {
	char *vector;
	char *type;
	char *date;
	char *origin;
};

struct EulabeiaPlugin {
	char *oid;
	char *name;
	char *filename;
	char *required_keys;
	char *mandatory_keys;
	char *excluded_keys;
	char *required_ports;
	char *required_udp_ports;
	char *category;
	char *family;
	char *created;
	char *modified;
	char *summary;
	char *solution;
	char *solution_type;
	char *solution_method;
	char *impact;
	char *insight;
	char *affected;
	char *vuldetect;
	char *qod_type;
	char *qod;
	struct EulabeiaPluginReferences *references;
	struct EulabeiaPluginParameters *parameters;
	struct EulabeiaPluginDependencies *dependencies;
	struct EulabeiaPluginSeverity *severity;
};

struct EulabeiaPlugins {
	struct EulabeiaPlugin *plugins;
	unsigned int len;
	unsigned int cap;
};

struct EulabeiaTarget {
	char *id;
	char *sensor;
	int alive;
	int parallel;
	struct EulabeiaHosts *hosts;
	struct EulabeiaPlugins *plugins;
	struct EulabeiaPorts *ports;
	struct EulabeiaHosts *exclude;
	struct EulabeiaCredentials *credentials;
};

struct EulabeiaScan {
	char *id;
	char *target_id; // set only target_id or target not both.
	struct EulabeiaHosts *finished;
	int temporary;
	struct EulabeiaTarget *target;
};
/*
 * @brief translates eulabeia_scan_state to an char array.
 *
 * The implementation of eulabeia_scan_state_to_str is generated via
 * the second parameter of EULABEIA_SCAN_STATES.
 *
 * @param[in] srs the eulabeia_scan_state to translate
 * @return a char array representation of eulabeia_scan_state or NULL
 * when undefined
 */
char *eulabeia_scan_state_to_str(enum eulabeia_scan_state srs);

/*
 * @brief translates eulabeia_message_type to an char array.
 *
 * The implementation of eulabeia_message_type_to_str is generated via
 * the second parameter of EULABEIA_MESSAGE_TYPES.
 *
 * @param[in] srs the eulabeia_message_type to translate
 * @return a char array representation of eulabeia_message_type or NULL when
 * undefined
 */
char *eulabeia_message_type_to_str(enum eulabeia_message_type mt);

/*
 * @brief translates eulabeia_aggregate to an char array.
 *
 * The implementation of eulabeia_aggregate_to_str is generated via
 * the second parameter of EULABEIA_AGGREGATES.
 *
 * @param[in] srs the eulabeia_aggregate to translate
 * @return a char array representation of eulabeia_aggregate or NULL when
 * undefined
 */
char *eulabeia_aggregate_to_str(enum eulabeia_aggregate mt);

/*
 * @brief translates an char array to eulabeia_aggregate.
 *
 * @param[in] rt the eulabeia_aggregate to translate
 * @return a eulabeia_aggregate
 */
enum eulabeia_aggregate eulabeia_aggregate_from_str(char *rt);

/*
 * @brief returns the eulabeia_message_type of a message.
 *
 * @param[in] message; the message to get the message_type from
 * @return eulabeia_message_type
 */
enum eulabeia_message_type
eulabeia_message_to_message_type(const struct EulabeiaMessage *message);

/*
 * @brief destroys an EulabeiaMessage
 *
 * @param[out] msg, the EulabeiaMessage to be freed. Sets *msg to NULL.
 */
void eulabeia_message_destroy(struct EulabeiaMessage **msg);

/*
 * @brief destroys an EulabeiaFailure
 *
 * @param[out] failure, the EulabeiaFailure to be freed. Sets *failure to NULL.
 */
void eulabeia_failure_destroy(struct EulabeiaFailure **failure);

/*
 * @brief destroys an EulabeiaStatus
 *
 * @param[out] status, the EulabeiaStatus to be freed. Sets *status to NULL.
 */
void eulabeia_status_destroy(struct EulabeiaStatus **status);

/*
 * @brief destroys an EulabeiaHosts
 *
 * @param[out] hosts, the EulabeiaHosts to be freed. Sets *hosts to NULL.
 */
void eulabeia_hosts_destroy(struct EulabeiaHosts **hosts);

/*
 * @brief destroys an EulabeiaPlugins
 *
 * @param[out] plugins, the EulabeiaPlugins to be freed. Sets *plugins to NULL.
 */
void eulabeia_plugins_destroy(struct EulabeiaPlugins **plugins);

/*
 * @brief destroys an EulabeiaPorts
 *
 * @param[out] ports, the EulabeiaPorts to be freed. Sets *ports to NULL.
 */
void eulabeia_ports_destroy(struct EulabeiaPorts **ports);

/*
 * @brief destroys an EulabeiaScanResult
 *
 * @param[out] scan_result, the EulabeiaScanResult to be freed. Sets
 * *scan_result to NULL.
 */
void eulabeia_scan_result_destroy(struct EulabeiaScanResult **scan_result);

/*
 * @brief destroys an EulabeiaHostStatus
 *
 * @param[out] scan_result, the EulabeiaScanResult to be freed. Sets
 * *scan_result to NULL.
 */
void eulabeia_host_status_destroy(struct EulabeiaHostStatus **status);

/*
 * @brief destroys an EulabeiaScanProgress
 *
 * @param[out] scan_progress, the EulabeiaScanProgress to be freed. Sets
 * *scan_progress to NULL.
 */
void eulabeia_scan_progress_destroy(
    struct EulabeiaScanProgress **scan_progress);

/*
 * @brief builds an message_type char array based on message_type and aggregate
 *
 * @param[in] message_type the eulabeia_message_type
 * @param[in] aggregata the eulabeia_aggregate
 * @param[in] destination the  message destination or NULL if no specific
 * target.
 *
 * @return a char array according to the definition of a message_type
 * (message_type.aggregate)
 */
char *eulabeia_message_type(enum eulabeia_message_type message_type,
			    enum eulabeia_aggregate aggregate,
			    char *destination);

/*
 * @brief initializes a valud EulabeiaMessage based on message_type, aggregate
 * and may group_id
 *
 * @param[in] message_type the eulabeia_message_type
 * @param[in] aggregata the eulabeia_aggregate
 * @param[in] group_id on NULL a new uuid as group_id will be set otherwise the
 * @param[in] destination the  message destination or NULL if no specific
 * target. message will contain the given group_id
 * @return an EulabeiaMessage or NULL on failure.
 */
struct EulabeiaMessage *
eulabeia_initialize_message(enum eulabeia_message_type message_type,
			    enum eulabeia_aggregate aggregate,
			    char *group_id,
			    char *destination);

/*
 * @brief translate given eulabeia_scan_state to a char representation
 *
 * @param[in] scan_state to translate
 * @return char array representation of given scan_state
 */
char *eulabeia_scan_state_to_str(enum eulabeia_scan_state srs);

/*
 * @brief translate given eulabeia_scan_state to a event type char array.
 *
 * The event type is used to calculate topic based on if given message_type is
 * an info or cmd event.
 *
 * @param[in] scan_state to translate
 * @return char array representation of the event type (cmd or info)
 */
char *eulabeia_message_type_to_event_type(enum eulabeia_message_type mt);

/*
 * @brief translate given eulabeia_message_type to a char representation
 *
 * @param[in] message_type to translate
 * @return char array representation of given message_type
 */
char *eulabeia_message_type_to_str(enum eulabeia_message_type mt);

/*
 * @brief translate given eulabeia_scan_state to a char representation
 *
 * @param[in] scan_state to translate
 * @return char array representation of given scan_state
 */
char *eulabeia_scan_state_to_str(enum eulabeia_scan_state srs);

/*
 * @brief translate given eulabeia_scan_state to a event type char array.
 *
 * The event type is used to calculate topic based on if given message_type is
 * an info or cmd event.
 *
 * @param[in] scan_state to translate
 * @return char array representation of the event type (cmd or info)
 */
char *eulabeia_message_type_to_event_type(enum eulabeia_message_type mt);

/*
 * @brief translate given eulabeia_message_type to a char representation
 *
 * @param[in] message_type to translate
 * @return char array representation of given message_type
 */
char *eulabeia_message_type_to_str(enum eulabeia_message_type mt);

/*
 * @brief translate given eulabeia_aggregate to a char representation
 *
 * @param[in] aggregate to translate
 * @return char array representation of given aggregate
 */
char *eulabeia_aggregate_to_str(enum eulabeia_aggregate a);

/*
 * @brief translate given eulabeia_result_type to a char representation
 *
 * @param[in] result_type to translate
 * @return char array representation of given result_type
 */
char *eulabeia_result_type_to_str(enum eulabeia_result_type rt);

/*
 * @brief translate a given char representation to eulabeia_result_type
 *
 * @param[in] string to translate
 * @return enum eulabeia_result_type
 */
enum eulabeia_result_type eulabeia_result_type_from_str(char *s);

/*
 * @brief translate given eulabeia_host_status_type to a char representation
 *
 * @param[in] host_status_type to translate
 * @return char array representation of given host_status_type
 */
char *eulabeia_host_status_type_to_str(enum eulabeia_host_status_type rt);

/*
 * @brief translate a given char representation to eulabeia_host_status_type
 *
 * @param[in] string to translate
 * @return enum eulabeia_host_status_type
 */
enum eulabeia_host_status_type eulabeia_host_status_type_from_str(char *s);
#endif
